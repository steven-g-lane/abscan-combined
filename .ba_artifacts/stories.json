{
    "stories": [
        {
            "name": "See main window view",
            "as_a": "user",
            "i_want": "to be able to view the main window view",
            "so_that": "I can get an overview of types and artifacts in my system",
            "ui_ux": "The main window displays three distinct areas in a dark theme layout. The top-left area contains Miller columns (cascading tree view) showing 4 empty columns initially, similar to macOS Finder navigation. This area takes approximately 75% of the window width and 55% of the window height. Below the Miller columns, in the same width area, is an expanded column view containing a data grid placeholder that shows the same entries as the last Miller column but with additional data columns. This grid takes the remaining vertical space in the left area. To the right of both left components is a fixed-width detail panel (25% of window width) that spans the full window height and shows detailed information about the currently selected item in the Miller columns. All three areas resize appropriately when the window dimensions change - the left areas resize with window width and height changes, while the right panel maintains fixed width but resizes height with the window.",
            "implementation_notes": "Set default Electron window size to 1111x729px to match mockup dimensions. Create 3-panel layout using CSS Grid or Flexbox. Left panel container (75% width) holds two stacked components: Miller columns component in top portion and expanded grid component in bottom portion. Right panel (25% fixed width, full height) for detail view. Miller columns should have macOS Finder-style appearance with 4 empty columns and navigation arrows. Expanded grid should be a placeholder table structure without specific column headers. Detail panel should have placeholder sections for future content. Use Tailwind @theme technology for all dark theme styling and color management. Ensure proper responsive behavior for window resizing.",
            "artifacts": [
                "./mockups/viewer-window-basic.jpg: Visual mockup showing the 3-panel layout with Miller columns, expanded grid, and detail panel"
            ],
            "acceptance_criteria": [
                "Main window opens with default size of 1111x729px",
                "Window displays 3 distinct areas: Miller columns (top-left), expanded grid (bottom-left), and detail panel (right)",
                "Miller columns area shows 4 empty columns with Finder-style navigation arrows",
                "Miller columns area takes approximately 75% of window width and 55% of window height",
                "Expanded grid area appears below Miller columns with same width as Miller columns",
                "Expanded grid area takes remaining vertical space in left panel area",
                "Detail panel appears on right side with fixed width of 25% of window",
                "Detail panel spans full height of window",
                "All areas use dark theme styling consistent with mockup",
                "When window width changes, left areas (Miller columns and expanded grid) resize proportionally",
                "When window height changes, Miller columns maintains proportion while expanded grid adjusts to fill remaining space",
                "Detail panel maintains fixed 25% width but adjusts height with window height changes",
                "Layout maintains proper proportions and usability at different window sizes"
            ]
        },
        {
            "name": "Resize main window",
            "as_a": "user",
            "i_want": "to be able to resize the main window",
            "so_that": "I can adjust the interface to fit my workspace and viewing preferences",
            "ui_ux": "Users can resize the main window using standard operating system window controls (drag corners/edges). The three-panel layout adapts smoothly to window size changes while maintaining proper proportions and usability.",
            "implementation_notes": "Implement responsive layout behavior for window resizing. Set appropriate minimum window dimensions to prevent layout breaking. Ensure all three panels (Miller columns, expanded grid, detail panel) respond appropriately to size changes as specified in the 'See main window view' story.",
            "acceptance_criteria": [
                "User can resize window using standard OS controls",
                "Layout maintains proper proportions during resize",
                "Minimum window size prevents layout from breaking",
                "All panel areas resize according to their specified behavior",
                "Window resize operations are smooth and responsive"
            ]
        },
        {
            "name": "Load data file",
            "as_a": "user",
            "i_want": "to see sample data in the Miller columns when the app opens",
            "so_that": "I can test the display and visualization capabilities of the Miller columns",
            "ui_ux": "When no data is loaded, the first Miller column displays 'Select File > Load File… to load data' as user guidance. When a user selects File>Load File… from the menu, a file dialog appears allowing selection of a JSON data file. After file selection, the Miller columns interface displays 'Loading data...' and prevents user interaction until processing completes. Once loaded, the first column displays entries from the selected JSON data file, each showing a Lucide icon to the left of the item name. The remaining three columns remain empty initially. A breadcrumb path appears at the bottom of the Miller columns area (initially empty). Individual columns have flexible width with a 200px minimum, distributing available space evenly. When an icon name from the JSON doesn't exist in Lucide, the system gracefully falls back to displaying a folder icon. Error conditions (malformed JSON, file permission issues, unsupported data structures) display clear error messages to the user.",
            "implementation_notes": "Implement File>Load File… menu item that triggers native file dialog for JSON file selection with proper file type filtering. Support standard JSON format where each entry contains 'name' (text label), 'icon' (Lucide icon name), and 'children' (array of child entries). Display loading state during file processing and prevent user interaction until complete. Implement comprehensive error handling for malformed JSON files, missing file permissions, and unsupported data structures with clear user-facing error messages. Display initial state message when no data is loaded. Handle icon fallback by catching Lucide icon errors and displaying folder icon as default. Set column minimum width to 200px with flexible width distribution. Display breadcrumb path at bottom of Miller columns area. Use Tailwind @theme colors for consistent styling.",
            "acceptance_criteria": [
                "When no data is loaded, first column displays 'Select File > Load File… to load data' guidance message",
                "File>Load File… menu item triggers native file dialog with JSON file filtering",
                "User can select JSON data file through file dialog",
                "File dialog provides proper error handling for file access issues",
                "App displays 'Loading data...' message while processing selected file",
                "Miller columns prevent user interaction during loading state",
                "First Miller column displays entries with names from JSON root level after successful load",
                "Each entry shows appropriate Lucide icon to the left of the name",
                "When Lucide icon name doesn't exist, system falls back to folder icon",
                "System gracefully handles malformed JSON files with clear error messages",
                "System handles missing file permissions with appropriate error messages",
                "System handles unsupported data structures with clear error messages",
                "Breadcrumb path appears at bottom of Miller columns area (initially empty)",
                "Columns have minimum width of 200px with flexible width distribution",
                "Entries use consistent dark theme styling with proper typography",
                "Second, third, and fourth columns remain empty initially",
                "JSON data structure supports hierarchical data with children arrays",
                "Loading data does not block the UI or cause performance issues"
            ]
        },
        {
            "name": "Click Miller column entry",
            "as_a": "user",
            "i_want": "to be able to click a Miller column entry and see the entry's children displayed in the next column to the right",
            "so_that": "I can navigate through the hierarchical data structure",
            "ui_ux": "When a user clicks on any entry in a Miller column, that entry becomes visually selected (highlighted) and its children appear in the immediately adjacent column to the right. The breadcrumb path at the bottom of the Miller columns updates to show the current selection path (e.g., 'Single files > AI.fmp12 > Tables'). If there are insufficient columns to display the children, a new column is dynamically added. When navigating back up the tree (selecting items in earlier columns), the interface reduces the number of columns to show only those needed: the current selection path plus the children column plus one blank column to the right. The interface maintains a minimum of 4 columns at all times. Columns maintain flexible width with 200px minimum, redistributing space as columns are added or removed. The selected entry maintains its highlighted state until a different entry is clicked.",
            "implementation_notes": "Implement dynamic column management: 1) Add columns when navigating deeper if insufficient columns exist, 2) Remove excess columns when navigating back up the tree, 3) Always maintain minimum of 4 columns, 4) Calculate needed columns as: selection path + children column + 1 blank column, 5) Set clicked item as selected with visual highlight, 6) Populate next column with children from JSON data, 7) Update breadcrumb path at bottom to reflect current selection path, 8) Maintain 200px minimum column width with flexible distribution during resize, 9) Update application state to track current selection path and column count. Use Tailwind @theme colors for selection highlighting.",
            "acceptance_criteria": [
                "Clicking any Miller column entry visually highlights the selected item",
                "Selected entry's children appear in the next column to the right",
                "Breadcrumb path at bottom updates to show current selection path (e.g., 'Single files > AI.fmp12 > Tables')",
                "New column is added dynamically if insufficient columns exist for children",
                "When navigating back up tree, excess columns are removed to show only needed columns",
                "Interface always maintains minimum of 4 columns regardless of navigation depth",
                "Column count calculation: selection path + children column + 1 blank column",
                "Columns maintain 200px minimum width with flexible distribution",
                "Column widths redistribute appropriately when columns are added or removed",
                "Only one entry can be selected at a time across all columns",
                "Selection highlighting uses appropriate theme colors",
                "Clicking entry with no children still shows selection but populates no additional columns",
                "Click interactions are responsive with immediate visual feedback",
                "Navigation state is properly maintained as user clicks through hierarchy",
                "Previously selected items are properly deselected when new selections are made"
            ]
        },
        {
            "name": "View Menu System",
            "as_a": "user",
            "i_want": "to view an OS-native menu system",
            "so_that": "I can interact naturally with the app and access functions exposed via the menus",
            "ui_ux": "When the application launches, a native menu bar appears at the top of the screen (macOS) or window (Windows/Linux) following OS conventions. The menu system includes appropriate menu items, keyboard shortcuts (accelerators), and visual separators as defined in the configuration. Menu items show proper enabled/disabled states and provide immediate feedback when clicked. In development mode (NODE_ENV=development), additional development tools appear in the menu (Reload, Force Reload, Toggle Developer Tools). In production mode, these development items are hidden. The menu appearance and behavior matches the operating system's native look and feel.",
            "implementation_notes": "Implement native menu system using Electron's Menu API. Load menu structure from ./config/menu-config.json at application startup. The JSON config defines complete menu hierarchy including labels, accelerators, roles, separators, and enabled states with conditional development menu items based on NODE_ENV. Use Menu.setApplicationMenu() to apply the menu system. Config file structure should align with Electron Menu template format for direct consumption. Implement IPC communication between main and renderer processes for menu actions, particularly File>Load File functionality. Configure preload script to securely expose IPC channels for menu-triggered actions. Handle file dialog operations with proper JSON file filtering and error handling for file access issues.",
            "artifacts": [
                "./config/menu-config.json: Complete menu structure configuration with all menu items, shortcuts, and metadata"
            ],
            "acceptance_criteria": [
                "Native menu bar appears following OS conventions (top of screen on macOS, window on Windows/Linux)",
                "Application loads menu structure from ./config/menu-config.json on startup",
                "Menu system displays all menus and items as defined in configuration file",
                "Menu items display correct keyboard shortcuts (accelerators) from config",
                "Visual separators appear between menu item groups as specified in config",
                "Menu items show proper enabled/disabled states from configuration",
                "Development tools (Reload, Force Reload, Toggle Developer Tools) appear only when NODE_ENV=development",
                "Development tools are hidden in production mode",
                "Clicking menu items provides immediate visual feedback",
                "Menu appearance matches native OS look and feel",
                "File>Load File menu item triggers IPC communication to renderer process",
                "File dialog filters specifically for JSON files",
                "File dialog provides proper error handling for file access issues",
                "IPC channels are securely configured through preload script",
                "Menu item clicks trigger appropriate application actions",
                "Config file uses structure compatible with Electron Menu API for direct consumption"
            ]
        },
        {
            "name": "Handle File Metadata",
            "as_a": "developer",
            "i_want": "the application to properly handle the new metadata elements in the JSON data from abscan",
            "so_that": "loading files with the new data structure doesn't break the application and all metadata is preserved",
            "ui_ux": "The metadata handling is invisible to users - they continue to interact with the Miller columns interface normally. The application gracefully processes files containing the new metadata elements without any visual changes to the current interface behavior.",
            "implementation_notes": "Extend existing TypeScript types and validation to include new 'metadata' property on data items. Update JSON parsing and data validation to handle metadata fields while maintaining backward compatibility with files that don't have metadata. Ensure the metadata is preserved in the application state when items are loaded and navigated. Update any existing data transformation logic to pass through metadata unchanged. The metadata should be available for future use by other components without breaking existing functionality.",
            "acceptance_criteria": [
                "Application successfully loads JSON files containing new metadata elements without errors",
                "TypeScript types are updated to include optional metadata property",
                "Data validation accepts and preserves metadata fields during JSON parsing",
                "Application maintains backward compatibility with JSON files without metadata",
                "Metadata is stored in application state alongside existing item properties",
                "Miller columns navigation continues to work normally with metadata-enhanced items",
                "No existing functionality is broken by the metadata handling changes",
                "Metadata is accessible to other components through the application's data layer",
                "Error handling gracefully manages malformed metadata without breaking file loading",
                "Application performance is not impacted by metadata processing"
            ]
        },
        {
            "name": "Display Item Metadata",
            "as_a": "user",
            "i_want": "to see detailed metadata about files and directories when I click on items in the Miller columns",
            "so_that": "I can understand more information about the selected item beyond just its name and children",
            "ui_ux": "When a user clicks any entry in the Miller columns (file or directory), the right-hand detail panel displays the item's metadata in a clean, readable HTML format. The metadata appears as key-value pairs with proper formatting, nested objects shown in an organized structure, and JSON data presented in a user-friendly way. Any existing placeholder content in the right panel is replaced with this metadata display component. The panel shows 'No metadata available' when an item has no metadata, and displays 'Select an item to view details' when no item is selected.",
            "implementation_notes": "Replace current right panel placeholder content with a new MetadataDisplay component. Create HTML-based component that takes JSON metadata and renders it in a pleasing, readable format with proper typography and spacing. Handle nested objects and arrays in the metadata display. Support different data types (strings, numbers, booleans, objects, arrays) with appropriate formatting. Use Tailwind styling for consistent theme integration. Component should be responsive and handle long content with appropriate scrolling. Integrate with Miller column click events to pass selected item's metadata to the display component.",
            "acceptance_criteria": [
                "Clicking any Miller column entry updates the right panel to show item metadata",
                "Metadata displays in clean, readable HTML format with proper typography",
                "Key-value pairs are clearly formatted and easy to scan",
                "Nested objects and arrays display in organized, hierarchical structure",
                "Different data types (strings, numbers, booleans, objects, arrays) show appropriate formatting",
                "Panel shows 'No metadata available' message when item has no metadata",
                "Panel shows 'Select an item to view details' when no item is selected",
                "Component uses consistent Tailwind dark theme styling",
                "Long metadata content scrolls properly within the panel bounds",
                "Existing placeholder content in right panel is completely replaced",
                "Component integrates seamlessly with Miller column click events",
                "Display updates immediately when different items are selected",
                "Component handles empty, null, or malformed metadata gracefully",
                "Metadata display is responsive to panel width changes during window resize"
            ]
        },
        {
            "name": "Keyboard shortcut for Load File",
            "as_a": "user",
            "i_want": "to be able to press Cmd-L (macOS) or Ctrl-L (Windows/Linux) to invoke the File Menu's Load File option",
            "so_that": "I can quickly load data files without navigating through the menu system",
            "ui_ux": "Users can press Cmd-L on macOS or Ctrl-L on Windows/Linux to immediately trigger the Load File functionality, which opens the same file dialog as selecting File > Load File from the menu. The keyboard shortcut works from anywhere in the application and provides the same file loading experience as the menu option.",
            "implementation_notes": "Register keyboard shortcut in the menu configuration (menu-config.json) for the Load File menu item using 'CommandOrControl+L' accelerator. Ensure the accelerator is properly configured to trigger the same IPC communication as the menu click. The shortcut should work globally within the application window and follow platform conventions (Cmd on macOS, Ctrl on Windows/Linux). Verify that the shortcut doesn't conflict with existing system shortcuts or browser shortcuts in Electron.",
            "acceptance_criteria": [
                "Pressing Cmd-L on macOS triggers the Load File dialog",
                "Pressing Ctrl-L on Windows/Linux triggers the Load File dialog", 
                "Keyboard shortcut opens the same file dialog as File > Load File menu option",
                "Shortcut works from anywhere within the application window",
                "Shortcut triggers the same IPC communication and file loading logic as menu click",
                "Accelerator key combination is displayed in the File menu next to Load File option",
                "Shortcut follows platform conventions (Cmd on macOS, Ctrl on Windows/Linux)",
                "Shortcut does not conflict with existing system or browser shortcuts",
                "Keyboard shortcut works consistently across different operating systems",
                "Pressing the shortcut provides the same user experience as clicking the menu item"
            ]
        },
        {
            "name": "Eliminate intermediate Miller columns files",
            "as_a": "developer",
            "i_want": "the CLI to store Miller columns data directly in abscan.json and eliminate separate files.json and miller-columns.json files",
            "so_that": "we reduce file system clutter, simplify the data pipeline, and have a single source of truth for all project data",
            "ui_ux": "This change is invisible to users - they continue to interact with the Miller columns interface normally. The application loads data from abscan.json with the same performance and functionality as before.",
            "implementation_notes": "Modify the CLI data pipeline to integrate Miller columns transformation into the abscan.json generation process. Keep existing logic from millerColumnsTransformer.ts (icon mapping, hierarchical transformation) but execute it in-memory during abscan.json creation instead of writing separate files. Update abscan.json structure to include a 'files' section containing Miller columns-compatible data with proper icon assignments and hierarchical structure. Modify MillerColumns.tsx to read from abscan.json's files section using the standardized data format (data.files.items). Remove file system writes for files.json and miller-columns.json. The aggregator.ts logic should be updated to build the files section directly rather than reading from intermediate files. All existing icon mapping logic, file type detection, and hierarchical transformation should be preserved but executed as part of the main scan process.",
            "acceptance_criteria": [
                "CLI no longer generates files.json as a separate output file",
                "CLI no longer generates miller-columns.json as a separate output file", 
                "abscan.json contains a 'files' section with Miller columns-compatible data structure",
                "Files section includes proper Lucide icon assignments for all file types and extensions",
                "Files section maintains hierarchical structure with children arrays for navigation",
                "MillerColumns.tsx successfully loads and displays data from abscan.json files section",
                "Miller columns navigation continues to work with same functionality as before",
                "Icon mapping logic continues to work with all supported file types and extensions",
                "File metadata is preserved in the files section for detail panel display",
                "CLI execution time is not significantly impacted by the consolidation",
                "abscan.json file size increase is reasonable given the elimination of separate files",
                "All existing CLI command line options continue to work as expected",
                "Error handling gracefully manages any issues with the consolidated data structure",
                "No functionality is lost in the Miller columns interface after the change"
            ]
        },
        {
            "name": "Eliminate intermediate classes file",
            "as_a": "developer",
            "i_want": "the CLI to store class analysis data directly in abscan.json and eliminate the separate classes.json file",
            "so_that": "we reduce file system clutter, simplify the data pipeline, and have a single source of truth for class analysis data",
            "ui_ux": "This change is invisible to users - they continue to interact with the Miller columns interface normally when browsing class hierarchies. The application loads class data from abscan.json with the same performance and functionality as before.",
            "implementation_notes": "Modify the CLI data pipeline to integrate class analysis transformation into the abscan.json generation process. Keep existing logic from classMillerColumnsTransformer.ts (hierarchical class structure, method/property organization) but execute it in-memory during abscan.json creation instead of writing separate files. The classes section in abscan.json already contains Miller columns-compatible data with proper icon assignments and hierarchical structure (Classes → ClassName → Methods/Properties → Individual items). Update aggregator.ts to build the classes section directly from the ClassAnalysisResult rather than reading from classes.json. Remove file system write for classes.json. All existing class analysis logic, reference tracking, and hierarchical transformation should be preserved but executed as part of the main scan process rather than creating intermediate files.",
            "acceptance_criteria": [
                "CLI no longer generates classes.json as a separate output file",
                "abscan.json continues to contain the existing 'classes' section with Miller columns-compatible data structure",
                "Classes section maintains hierarchical structure (Classes → ClassName → Methods → Individual methods)",
                "Classes section includes proper icon assignments for classes, methods, and properties",
                "Miller columns interface successfully displays class hierarchies from abscan.json classes section",
                "Class navigation in Miller columns continues to work with same functionality as before",
                "All class analysis metadata (references, locations, method signatures) is preserved in abscan.json structure",
                "Class detail panel continues to show comprehensive class information when items are selected",
                "CLI execution time is not significantly impacted by the consolidation",
                "abscan.json file size increase is reasonable given the elimination of classes.json",
                "All existing CLI command line options for class analysis continue to work as expected",
                "Error handling gracefully manages any issues with the consolidated class data structure",
                "No functionality is lost in the class browsing interface after the change",
                "Class reference tracking and dependency analysis data is retained for future use"
            ]
        },
        {
            "name": "Scan chosen directory",
            "as_a": "user",
            "i_want": "to be able to choose a directory to scan from within the viewer application",
            "so_that": "I can generate new scan files for different applications without using the command line",
            "ui_ux": "When a user selects File > Scan… from the menu, a directory picker dialog appears allowing selection of the root directory to scan. The default selection is the current working directory where the Electron app was launched. After directory selection, the scanning process begins and the UI shows a loading state with 'Scanning project...' message, blocking user interaction until completion. Once scanning finishes, a second dialog appears prompting for the output directory to save scan results. The default output location is '/output' inside the chosen scan directory, but users can change this to any writable location. After output directory selection, the scan files are written and the operation completes silently - no success message is shown, allowing users to then manually load the generated files via File > Load File.",
            "implementation_notes": "Add 'Scan…' menu item to File menu in menu configuration. Implement IPC communication between main and renderer processes for directory selection and scanning operations. Use native directory picker dialogs for both root directory and output directory selection. Execute CLI scanning functionality from within the Electron main process using default scan settings (ignore node_modules, scan all other files). During scanning, display blocking loading state in renderer with appropriate messaging. Handle scan errors by displaying the most recent error from the stack trace in an error dialog. Use the same CLI scanning logic as the command-line version but triggered from the GUI. Ensure proper file permissions and error handling for both directory selection and file writing operations.",
            "acceptance_criteria": [
                "File menu contains new 'Scan…' menu item",
                "Clicking 'Scan…' opens native directory picker dialog",
                "Directory picker defaults to current working directory where app was launched",
                "After directory selection, scanning process begins automatically",
                "UI displays 'Scanning project...' loading state during scan operation",
                "User interface is blocked from interaction during scanning process",
                "Scanning uses default CLI settings: ignore node_modules, scan all other file types",
                "After scan completion, output directory picker dialog appears",
                "Output directory picker defaults to '/output' subdirectory of chosen scan root",
                "User can change output directory to any writable location",
                "Scan files are written to chosen output directory upon completion",
                "No success message is displayed after scanning completes",
                "If scanning fails, error dialog shows most recent error from stack trace",
                "All scan functionality matches command-line version behavior",
                "Menu item works consistently across different operating systems",
                "Directory pickers provide proper error handling for access permission issues",
                "Generated files are identical to those created by CLI with same parameters",
                "Scanning operation does not interfere with existing loaded data until user manually loads new files"
            ]
        },
        {
            "name": "Scan configuration interface",
            "as_a": "user",
            "i_want": "to configure scan settings through a graphical interface before starting a scan",
            "so_that": "I can customize the scanning process for different projects and requirements without using command line options",
            "ui_ux": "When a user selects File > Scan… from the menu, a modal dialog titled 'Scan Application' appears with configuration options. The dialog contains four main settings: (1) Scan Path field showing the default directory where the Electron app was invoked from, with a 'Choose…' button that opens a native directory picker, (2) Output Path field showing '/output' subdirectory of the currently selected scan path, with a 'Choose…' button for native directory selection, (3) 'Include node_modules' toggle switch defaulting to off, and (4) 'Include .git directory' toggle switch defaulting to off. At the bottom are 'Cancel' and 'Scan' buttons. The Scan button is disabled until path validation passes. When paths are invalid (scan path doesn't exist, output path not writable), appropriate error messages appear below the respective fields. The dialog follows the application's dark theme styling and uses native OS directory pickers with 'Choose' instead of 'Open' labels.",
            "implementation_notes": "Create a modal dialog component using React that integrates with the existing menu system. Replace the current simple File > Scan... behavior with this configuration dialog. Implement form state management for the four configuration options with real-time validation. Use native directory pickers through Electron's dialog API for both path selections, customizing button labels to show 'Choose' instead of 'Open'. Implement path validation: verify scan path exists using fs.exists() and output path is writable using fs.access() with write permissions. Show validation errors inline below each path field. When user clicks 'Scan', pass the configured options to the same CLI scanning logic used in the command line version. Preserve all existing CLI scanning functionality but use GUI-selected options instead of command line arguments. Use Tailwind dark theme styling consistent with the rest of the application. Implement proper IPC communication for directory picker dialogs and path validation.",
            "acceptance_criteria": [
                "File > Scan… menu item opens 'Scan Application' modal dialog",
                "Dialog displays scan path field with current working directory as default",
                "Scan path 'Choose…' button opens native directory picker with 'Choose' label",
                "Dialog displays output path field with '/output' subdirectory of scan path as default",
                "Output path 'Choose…' button opens native directory picker with 'Choose' label", 
                "When scan path changes, output path automatically updates to scanpath/output",
                "'Include node_modules' toggle switch displays and defaults to off",
                "'Include .git directory' toggle switch displays and defaults to off",
                "'Cancel' button closes dialog without taking action",
                "'Scan' button triggers scanning with configured options and closes the configuration dialog",
                "Scan button is disabled when path validation fails",
                "Invalid scan path shows error message 'Directory does not exist' below field",
                "Invalid output path shows error message 'Directory not writable' below field",
                "Path validation runs in real-time as user types or selects directories",
                "Dialog uses consistent dark theme styling with Tailwind",
                "Directory pickers use native OS appearance with proper 'Choose' labeling",
                "Configured options are passed correctly to CLI scanning logic",
                "All CLI scanning functionality works identically to command line version",
                "Dialog is modal and prevents interaction with main application until closed",
                "Directory picker operations handle permissions errors gracefully"
            ]
        },
        {
            "name": "Show scan progress indicator",
            "as_a": "user", 
            "i_want": "to see visual progress when a scan is running",
            "so_that": "I know the scan is actively working and can see what stage it's currently processing",
            "ui_ux": "After clicking 'Scan' in the scan configuration dialog, that dialog closes and a new modal progress dialog appears titled 'Scanning Application'. The dialog displays real-time progress information showing the current scanning activity. Users can see what files or components are currently being processed. The dialog includes a 'Cancel' button to stop the scan if needed. When the scan completes successfully, the dialog automatically closes. If the scan fails, the dialog shows the error information and requires user acknowledgment to close. The progress display can be either a simple log of CLI stdout messages or a more sophisticated progress indicator - the engineering team should recommend the most feasible approach.",
            "implementation_notes": "Create a modal progress dialog component that appears when scanning begins. Implement IPC communication to receive real-time progress updates from the CLI scanning process. Two implementation approaches to consider: (1) Stream CLI stdout/stderr messages and display them in a scrollable log format, or (2) Parse scanning stages and show structured progress with percentage completion. Provide 'Cancel' functionality that can terminate the scanning process. Handle scan completion by automatically closing the dialog on success, or showing error details on failure. Use consistent dark theme styling with Tailwind. The dialog should be non-resizable but sized appropriately for content display. Engineering team should evaluate feasibility of both simple log display versus sophisticated progress tracking and recommend the best approach.",
            "acceptance_criteria": [
                "Progress dialog appears immediately when scan begins from configuration dialog",
                "Scan configuration dialog closes when scanning starts",
                "Progress dialog displays title 'Scanning Application'",
                "Dialog shows real-time indication of scan progress and current activity",
                "Users can see what files or components are currently being processed",
                "'Cancel' button is available to stop the scan operation",
                "Clicking 'Cancel' successfully terminates the scanning process",
                "Dialog automatically closes when scan completes successfully",
                "On scan failure, dialog shows error information and waits for user acknowledgment",
                "Dialog uses consistent dark theme styling with existing application",
                "Dialog is modal and prevents interaction with main application during scan",
                "Progress information updates smoothly without UI performance issues",
                "Dialog is properly sized for progress content display",
                "IPC communication reliably streams progress data from CLI process",
                "Error states are clearly communicated to the user",
                "Engineering team provides recommendation on simple vs sophisticated progress approach"
            ]
        },
        {
            "name": "Investigate class processing performance",
            "as_a": "user",
            "i_want": "class analysis scanning to complete quickly enough for repeated testing and what-if scenarios",
            "so_that": "I can efficiently iterate on code analysis without waiting minutes for each scan to complete",
            "ui_ux": "This is primarily a performance improvement that users will experience as faster scan completion times. The existing scan progress indicator should show noticeably faster class analysis stages, and users should be able to run multiple scans in succession without significant wait times.",
            "implementation_notes": "Conduct comprehensive performance analysis of the class processing pipeline to identify bottlenecks causing multi-minute scan times. Profile the following areas: (1) ts-morph Project initialization and file loading, (2) ClassAnalyzer.analyzeClasses() method and its sub-operations, (3) Type reference tracking and resolution, (4) Class relationship mapping and dependency graph building, (5) File I/O operations during class analysis, (6) Memory usage patterns that might cause garbage collection delays. Investigate potential optimizations: parallel processing of source files, caching of TypeScript compilation results, optimized ts-morph configuration, lazy loading strategies, incremental analysis for unchanged files, and algorithmic improvements in reference tracking. Document performance bottlenecks found and recommend specific optimizations with estimated impact. Implement the most effective improvements that maintain analysis accuracy while significantly reducing processing time.",
            "acceptance_criteria": [
                "Performance analysis identifies specific bottlenecks causing slow class processing",
                "Bottleneck analysis covers ts-morph initialization, class analysis methods, type tracking, and I/O operations",
                "Documentation clearly describes performance issues found and their impact",
                "Recommended optimizations include estimated performance improvement percentages",
                "Implementation of optimizations reduces class analysis time by at least 50%",
                "Optimized class analysis maintains full accuracy of type detection and reference tracking",
                "Memory usage during class analysis is optimized to prevent garbage collection delays",
                "Class analysis performance is consistent across different project sizes",
                "Repeated scans on the same project show improved performance through caching or incremental analysis",
                "Performance improvements do not break existing class analysis functionality",
                "All class metadata, relationships, and references continue to be captured correctly",
                "Progress indicator shows noticeably faster completion of class analysis stages",
                "Users can run multiple scans in testing scenarios without significant wait times",
                "Performance optimizations are well-documented for future maintenance",
                "Class analysis scales appropriately with project complexity"
            ]
        },
        {
            "name": "Auto-open scanned data",
            "as_a": "user",
            "i_want": "an option to automatically open the scanned data files after scanning completes",
            "so_that": "I don't have to manually navigate and load the files after each scan",
            "ui_ux": "In the 'Scan Application' configuration dialog, a fifth option appears: 'Auto-open scanned files' toggle switch that defaults to enabled (true). When this option is enabled and scanning completes successfully, the application automatically loads the generated abscan.json file into the Miller columns interface without requiring user interaction. When the option is disabled, scanning completes silently as before, requiring manual file loading. The toggle switch appears below the existing four configuration options (scan path, output path, include node_modules, include .git) and follows the same styling as the other toggle switches.",
            "implementation_notes": "Add a fifth configuration option to the scan settings dialog: a toggle switch labeled 'Auto-open scanned files' that defaults to true. Include this setting in the form state management alongside the existing four options. When scanning completes successfully and this option is enabled, automatically trigger the same file loading logic used by the File > Load File menu action, pointing to the generated abscan.json file in the specified output directory. Ensure the auto-load functionality integrates seamlessly with the existing Miller columns data loading system. The auto-load should only occur on successful scan completion, not on scan errors or cancellation. Use the same toggle switch styling and behavior as the existing node_modules and .git directory toggles.",
            "acceptance_criteria": [
                "'Auto-open scanned files' toggle switch appears in scan configuration dialog",
                "Toggle switch is positioned below the existing four configuration options",
                "Toggle switch defaults to enabled (true) state",
                "Toggle switch follows same styling and behavior as node_modules and .git toggles",
                "When enabled and scan completes successfully, abscan.json is automatically loaded",
                "Auto-load uses the same file loading logic as File > Load File menu action",
                "Auto-load points to the abscan.json file in the configured output directory",
                "Miller columns interface displays the scanned data automatically after successful scan",
                "When disabled, scan completion behavior remains unchanged (silent completion)",
                "Auto-load does not occur when scan fails or is cancelled by user",
                "Auto-load functionality integrates seamlessly with existing data loading system",
                "Toggle state is properly managed in form state alongside other configuration options",
                "Auto-loaded data replaces any previously loaded data in the interface",
                "Error handling gracefully manages cases where auto-load fails after successful scan",
                "User can still manually load different files even when auto-load is enabled"
            ]
        },
        {
            "name": "Enhanced bottom panel display system",
            "as_a": "user",
            "i_want": "to see contextual information in the bottom left panel based on what's selected in the Miller columns",
            "so_that": "I can get additional details and insights about selected items beyond what's shown in the right panel",
            "ui_ux": "The bottom left panel (75% width, 45% height of content area) displays different content based on the selected item in Miller columns. When no item is selected, it shows 'No item selected'. The panel maintains consistent sizing and positioning regardless of content. Content is displayed with appropriate styling, scrolling when needed, and clear visual hierarchy.",
            "implementation_notes": "Create a flexible display system in the bottom panel that can show different content types based on selected item context. The panel should maintain fixed proportional sizing (75% width, 45% height) and handle different content types gracefully. Note that there's already some event that fires to update the right-hand panel with info on what was selected. So we should at least consider tapping into that. It may be that we need a parallel mechanism but we should look to see what's there. Implement proper empty state handling and ensure content is properly contained within panel boundaries with scrolling when necessary.",
            "acceptance_criteria": [
                "Bottom panel maintains 75% width and 45% height of content area at all times",
                "Panel shows 'No item selected' when no Miller column item is selected",
                "Panel content updates immediately when Miller column selection changes", 
                "Content is properly contained within panel boundaries with scrolling when needed",
                "Panel maintains consistent visual styling with rest of application",
                "Different content types can be displayed based on selection context",
                "Empty state is clearly communicated to users",
                "Panel sizing remains fixed regardless of content type or amount"
            ]
        },
        {
            "name": "Display file details",
            "as_a": "user", 
            "i_want": "to see file contents when I select a file in the Miller columns",
            "so_that": "I can quickly preview and examine file contents without opening them in an external editor",
            "ui_ux": "When a user selects a file (leaf node with no children) in the Miller columns, the bottom left panel displays the file's contents. For files under 5000 lines, the full content is shown in a monospace font with scrolling capability. Files over 5000 lines show a message 'File too large to display (X lines)'. Non-text files or binary files show 'Binary file - cannot display contents'. The content area has proper padding and uses the application's dark theme colors for optimal readability.",
            "implementation_notes": "Implement file content reading functionality that loads and displays file contents for selected files in Miller columns. Add file size validation to limit display to files under 5000 lines. Implement binary file detection to prevent display of non-text content. Use monospace font family for code display with appropriate line height and padding. Integrate with existing Miller column selection events to trigger file loading when a file (leaf) is selected. Handle file read errors gracefully with appropriate error messages. Use efficient file reading to avoid blocking the UI for larger files within the limit.",
            "acceptance_criteria": [
                "Selecting a file in Miller columns displays file contents in bottom panel",
                "File contents display only for leaf nodes (files with no children)",
                "Files under 5000 lines show full content with scrolling",
                "Files over 5000 lines show 'File too large to display (X lines)' message",
                "Binary files show 'Binary file - cannot display contents' message", 
                "Content uses monospace font family for proper code formatting",
                "Content area has appropriate padding and dark theme colors",
                "File reading integrates with existing Miller column selection mechanism",
                "File read errors display appropriate error messages to user",
                "Large file handling doesn't block or freeze the UI",
                "Content scrolls properly when file exceeds panel height",
                "Panel maintains proper sizing while displaying file contents"
            ]
        },
        {
            "name": "Attempt file type detection",
            "as_a": "user",
            "i_want": "the scanner to automatically detect and classify file types during scanning",
            "so_that": "I can see detailed file type information in the metadata when selecting files in the Miller columns",
            "ui_ux": "When a user selects any file in the Miller columns, the right-hand metadata panel displays the detected file type information alongside other metadata. This includes the MIME type (e.g., 'text/javascript', 'image/png') and binary file status. The file type detection happens automatically during scanning without user intervention and provides consistent classification across all scanned files.",
            "implementation_notes": "Create a FileTypeDetector class that analyzes local file paths and returns comprehensive file type information. The class should implement a multi-stage detection strategy: (1) Use mime-types package for extension-based detection first, (2) If that fails, use file-type package for magic number/content-based detection, (3) As final fallback, use isBinaryFile package to at least determine binary vs text status. The FileTypeDetector should return a FileDetectionResult object containing: isBinaryFile (boolean), mimeType (string), confidence (enum: 'high'|'medium'|'low'), detectionMethod (enum: 'extension'|'content'|'fallback'), and any additional metadata the team deems useful (file size, encoding detection, etc.). Integrate this detector into the file system scanning process so that file type metadata is automatically added to each scanned file. The detected information should be stored in the file's metadata object and displayed in the right-hand panel when files are selected. Handle edge cases gracefully: files without extensions, corrupted files, permission-denied files, and very large files. Consider performance implications for large directories and implement efficient detection that doesn't significantly slow down scanning. The implementation should be extensible to support custom file type rules and detection logic in the future.",
            "acceptance_criteria": [
                "FileTypeDetector class implements multi-stage detection strategy",
                "Primary detection uses mime-types package for extension-based classification",
                "Secondary detection uses file-type package for content-based analysis",
                "Fallback detection uses isBinaryFile package for binary vs text determination",
                "FileDetectionResult object includes isBinaryFile, mimeType, confidence, and detectionMethod fields",
                "File type detection integrates automatically into file system scanning process",
                "Detected file type information appears in file metadata during scanning",
                "Right-hand metadata panel displays file type information when files are selected",
                "Detection handles files without extensions gracefully",
                "Detection handles permission-denied files without breaking scan process",
                "Detection handles corrupted or malformed files without errors",
                "File type detection doesn't significantly impact scanning performance",
                "Binary file detection accurately identifies non-text files",
                "MIME type detection covers common file types (js, ts, css, html, json, images, etc.)",
                "Detection confidence levels are assigned appropriately based on method used",
                "Detection method tracking allows debugging and optimization of classification accuracy",
                "Implementation is extensible for future custom file type rules",
                "Large files are handled efficiently without memory issues during detection",
                "File type metadata integrates seamlessly with existing metadata display system"
            ]
        },
        {
            "name": "Detect code files",
            "as_a": "user",
            "i_want": "the scanner to automatically determine whether non-binary files contain code or programming content",
            "so_that": "I can quickly identify which files are source code, configuration, or data files when browsing the Miller columns",
            "ui_ux": "When a user selects any non-binary file in the Miller columns, the right-hand metadata panel displays code detection information alongside other metadata. This includes whether the file is classified as code (boolean), the detected programming language or file type, and the confidence level of the detection. Code files are clearly identified with language hints (e.g., 'JavaScript', 'Python', 'CSS') while non-code files show as 'Plain text', 'CSV data', etc. The detection happens automatically during scanning without user intervention.",
            "implementation_notes": "Extend the FileTypeDetector class with code detection capabilities that analyze non-binary files to determine if they contain programming content. Implement a multi-stage detection pipeline: (1) MIME type analysis using predefined code type mappings (text/x-*, application/javascript, text/html, application/json, etc.), (2) Shebang line detection for scripts (#!/usr/bin/python, #!/bin/bash, etc.), (3) Editor modeline parsing (Emacs -*- python -*- or Vim filetype comments), (4) Extension-based fallback for common code extensions (.py, .js, .ts, .jsx, .tsx, .c, .h, .cpp, .java, .go, .rs, .rb, .php, .sql, .yml, .toml, .sh, etc.), (5) Lightweight structural analysis for data formats (JSON/XML parsing, YAML structure detection). The detector should return enhanced FileDetectionResult with additional fields: isCode (boolean), languageHint (string like 'javascript', 'python', 'css'), codeConfidence ('high'|'medium'|'low'), and codeDetectionMethod ('mime'|'shebang'|'modeline'|'extension'|'structure'). Use opinionated defaults: prefer false negatives over false positives, treat JSON/XML/YAML/TOML/INI as code/config files, handle Markdown as code-worthy, and mark CSV/plain text as non-code unless overridden by other signals. Integrate language hint mapping for common languages to provide consistent identifiers for potential future syntax highlighting. Performance must remain efficient for large codebases - avoid heavy parsing or content analysis that would slow scanning significantly.",
            "acceptance_criteria": [
                "FileDetectionResult object includes isCode, languageHint, codeConfidence, and codeDetectionMethod fields",
                "MIME type analysis correctly identifies code types (text/x-*, application/javascript, text/html, etc.)",
                "Shebang line detection identifies script files and maps to appropriate languages",
                "Editor modeline parsing detects Emacs and Vim file type declarations",
                "Extension-based detection covers common code file extensions",
                "JSON, XML, YAML, TOML, and INI files are classified as code/config files",
                "CSV and plain text files are classified as non-code by default",
                "Markdown files are classified as code-worthy content",
                "Language hint mapping provides consistent identifiers (javascript, python, css, html, etc.)",
                "Code detection doesn't significantly impact file system scanning performance",
                "Detection handles files without extensions using other signals",
                "False negatives are preferred over false positives in classification",
                "Confidence levels accurately reflect detection method reliability",
                "Right-hand metadata panel displays code classification when files are selected",
                "Code detection integrates seamlessly with existing file type detection",
                "Detection method tracking allows debugging of classification decisions",
                "Large files are processed efficiently without memory or performance issues",
                "Edge cases (permission denied, corrupted files) are handled gracefully",
                "Code detection results are stored in file metadata during scanning process"
            ]
        },
        {
            "name": "Display syntax highlighting for code files",
            "as_a": "user",
            "i_want": "to see syntax highlighted code with line numbers when viewing code files in the bottom left panel",
            "so_that": "I can easily read and understand the code structure with proper visual formatting",
            "ui_ux": "When a user selects a code file in the Miller columns, the bottom left panel displays the file contents with full syntax highlighting, line numbers, and proper code formatting. The display uses a dark theme syntax highlighting scheme that matches the application's overall dark theme. Line numbers appear on the left side in a muted color. The code content uses appropriate colors for keywords, strings, comments, and other language elements. Non-code files continue to display as plain text without syntax highlighting. The syntax highlighter automatically detects the programming language based on the file's detected code type and language hint from the file type detection system.",
            "implementation_notes": "Integrate react-syntax-highlighter library to provide syntax highlighting capabilities for the bottom panel file display. Create a CodeDisplay component that wraps the existing file content display and applies syntax highlighting when the selected file is classified as code (isCode: true from file type detection). Use the languageHint from FileDetectionResult to determine the appropriate syntax highlighting language. Configure react-syntax-highlighter with: (1) Dark theme style that matches application theming, (2) Line numbers enabled with proper styling, (3) Language mapping from detected languageHint to react-syntax-highlighter language identifiers, (4) Proper scrolling and overflow handling within the panel bounds. Implement fallback behavior: if syntax highlighting fails or language is not supported, gracefully fall back to plain text display with monospace formatting. The component should handle the transition between code and non-code files seamlessly, showing highlighted code for detected code files and plain text for everything else. Ensure performance remains good for files up to the 5000 line limit by using efficient highlighting algorithms and proper virtualization if needed.",
            "acceptance_criteria": [
                "Code files display with full syntax highlighting in bottom left panel",
                "Line numbers appear on left side with muted color styling",
                "Syntax highlighting uses dark theme colors matching application theme",
                "Language detection uses languageHint from file type detection system",
                "Non-code files continue to display as plain text without highlighting",
                "Highlighting covers common languages: JavaScript, TypeScript, Python, CSS, HTML, JSON, XML, YAML, etc.",
                "Component gracefully falls back to plain text if highlighting fails",
                "Language mapping correctly translates detection hints to highlighter language IDs",
                "Syntax highlighting performance doesn't impact UI responsiveness",
                "Code display maintains proper scrolling within panel boundaries",
                "Line numbers and content alignment are properly maintained",
                "Dark theme syntax colors provide good readability and contrast",
                "Component handles transition between code and non-code files seamlessly",
                "Large code files (up to 5000 lines) highlight efficiently without freezing UI",
                "Syntax highlighting integrates cleanly with existing file content display logic",
                "Error handling prevents highlighting failures from breaking file display",
                "Component maintains consistent styling with rest of application",
                "Code formatting preserves original indentation and spacing"
            ]
        },
        {
            "name": "Display child items in detail panel",
            "as_a": "user",
            "i_want": "to see a list of child items in a data grid when I select a Miller columns item that has children",
            "so_that": "I can view detailed information about all children at once instead of navigating through them individually",
            "ui_ux": "When a user selects any item in the Miller columns that has children, the bottom left panel displays those children in a data grid format. The grid shows multiple columns of information about each child item, with column headers and sortable rows. The specific columns displayed vary depending on the type of parent item selected (directories show file system metadata, classes show method/property details, etc.). The grid uses the application's dark theme styling with proper row highlighting on hover and clear column separation. Items with no children are handled by other components and are out of scope for this story.",
            "implementation_notes": "Create a flexible ChildItemsGrid component that can display different column configurations based on the selected item type. Implement an abstracted grid system that accepts a column configuration object defining: column headers, data field mappings, custom renderers for specific data types, and sorting behavior. The component should integrate with the existing Miller column selection mechanism and display different grid layouts based on the parent item's type or metadata. Use a data grid library or custom implementation that supports: sortable columns, hover effects, proper scrolling within panel bounds, and dark theme styling. The grid system must be extensible to support different item types (directories, classes, modules, etc.) with their own specific column configurations. Note that items with no children are handled elsewhere and are out of scope for this implementation. The component should efficiently handle large numbers of child items without performance degradation.",
            "acceptance_criteria": [
                "Child items display in data grid format when parent item has children",
                "Grid shows appropriate columns based on selected item type",
                "Grid uses dark theme styling consistent with application",
                "Column headers are clearly labeled and visually distinct",
                "Rows have hover effects for better user interaction",
                "Grid supports sorting by clicking column headers",
                "Component efficiently handles large numbers of child items",
                "Grid scrolls properly within bottom panel boundaries",
                "Grid system is abstracted and reusable for different item types",
                "Column configuration is flexible and extensible",
                "Grid integrates seamlessly with Miller column selection events",
                "Performance remains good when displaying many child items",
                "Grid maintains proper alignment and spacing",
                "Component handles data loading and error states gracefully",
                "Items with no children are explicitly out of scope for this component"
            ]
        },
        {
            "name": "Display directory file listing",
            "as_a": "user",
            "i_want": "to see detailed file and directory information when I select a directory in the Files section",
            "so_that": "I can view comprehensive file system metadata for all items in the selected directory",
            "ui_ux": "When a user selects a directory item under the Files section in Miller columns, the bottom left panel displays a data grid showing all children (files and subdirectories) of that directory. The grid contains six columns: (1) Name with appropriate icon (same icons as Miller columns), (2) Last Modified timestamp in readable format, (3) Size in human-readable format (bytes, KB, MB as appropriate, directories show dash or item count), (4) Owner (file system owner), (5) Group (file system group), (6) Permissions in standard format (rwxrwxrwx or octal). All items are sorted alphabetically by name by default. Users can click column headers to resort by that column. The display uses monospace font for consistent alignment and the application's dark theme colors.",
            "implementation_notes": "Implement directory-specific grid configuration for the ChildItemsGrid component. Create file system metadata collection during scanning to gather: modification timestamps, file sizes, owner/group information, and file permissions. The grid should use the same icon rendering logic as Miller columns for consistency. Implement proper file size formatting (bytes → KB → MB → GB with appropriate precision). Handle timestamp formatting in a readable format (e.g., 'Dec 15, 2024 3:45 PM' or relative time). For directories, show either a dash for size or item count as appropriate. Implement sorting functionality for all columns with appropriate data type handling (strings, numbers, dates). Use monospace font family for the grid to ensure proper column alignment. The implementation should reuse the abstract ChildItemsGrid system and demonstrate how different item types can provide their own column configurations. Handle edge cases: files without metadata, permission-denied files, and symbolic links. Ensure file system metadata collection doesn't significantly impact scanning performance.",
            "acceptance_criteria": [
                "Directory selection displays data grid with all directory children",
                "Grid shows Name, Last Modified, Size, Owner, Group, and Permissions columns",
                "Name column displays appropriate icons matching Miller columns",
                "Last Modified shows timestamps in readable format",
                "Size column shows human-readable format (bytes, KB, MB) with proper precision",
                "Directories show dash or item count in size column",
                "Owner and Group columns display file system ownership information",
                "Permissions column shows standard format (rwxrwxrwx or octal)",
                "Items are sorted alphabetically by name by default",
                "All column headers are clickable for sorting",
                "Sorting works correctly for different data types (text, numbers, dates)",
                "Grid uses monospace font for consistent column alignment",
                "Grid follows application's dark theme styling",
                "File system metadata is collected efficiently during scanning process",
                "Grid handles edge cases (missing metadata, permission denied) gracefully",
                "Implementation demonstrates reusable ChildItemsGrid system",
                "Grid performance remains good for directories with many items",
                "Component integrates seamlessly with Miller column directory selection",
                "Grid maintains proper scrolling and layout within panel bounds"
            ]
        },
        {
            "name": "Handle featureless children",
            "as_a": "user",
            "i_want": "to see a simplified single-column data grid when viewing items that have children with no additional metadata",
            "so_that": "I can browse child items that only have names without cluttered empty metadata columns",
            "ui_ux": "When a user selects a Miller columns item that has the 'featurelessChildren' property set to true, the bottom left panel displays a simplified data grid with only a single 'Name' column. Each row shows just the child item's name, identical to how it appears in the Miller columns. The grid maintains the same dark theme styling and hover effects as the full metadata grid, but without empty or irrelevant metadata columns. This provides a clean, focused view for items like class methods or properties where additional metadata doesn't apply.",
            "implementation_notes": "Extend the ChildItemsGrid component to detect when the selected parent item has 'featurelessChildren: true' in its metadata and render a simplified single-column grid layout. The grid should show only the 'Name' column with child item names matching exactly what appears in the Miller columns. The renderer should work generically for ANY item with the featurelessChildren attribute set to true, not specifically for classes. During scanning, update the class analysis process to automatically flag class entries (any child of the root Classes node) with the 'featurelessChildren: true' property - classes are the first concrete example of this pattern, but the rendering system should be generic. The simplified grid should maintain all the same interaction capabilities (hover effects, consistent styling) as the full metadata grid but without the complexity of multiple columns. Implement this as a configuration option in the grid system rather than a separate component, demonstrating the flexibility of the abstracted ChildItemsGrid design. The grid should handle the transition between full metadata display and simplified display seamlessly based on the parent item's featurelessChildren property.",
            "acceptance_criteria": [
                "Items with 'featurelessChildren: true' display single-column grid in bottom panel",
                "Simplified grid shows only 'Name' column with child item names",
                "Child names in grid match exactly what appears in Miller columns",
                "Grid maintains dark theme styling and hover effects",
                "Renderer works generically for ANY item with featurelessChildren attribute, not just classes",
                "Class entries are automatically flagged with 'featurelessChildren: true' during scanning",
                "All children of root Classes node have featurelessChildren property set",
                "Grid system handles transition between full and simplified layouts seamlessly",
                "Simplified grid uses same ChildItemsGrid component with different configuration",
                "Grid performance remains good for large numbers of featureless children",
                "Component properly detects featurelessChildren property from parent metadata",
                "Simplified grid maintains proper scrolling within panel boundaries",
                "Grid styling is consistent whether showing full metadata or simplified view",
                "Class scanning process is updated to add featurelessChildren metadata",
                "Grid handles cases where featurelessChildren property is missing or false",
                "Implementation demonstrates flexibility of abstracted grid system for future item types"
            ]
        }
    ]
}